# Lessons from OSV_ Vulnerability Management for Open Source

**Video URL:** [https://www.youtube.com/watch?v=qHcpKW2nOqI](https://www.youtube.com/watch?v=qHcpKW2nOqI)
**Video ID:** qHcpKW2nOqI

---

SUMMARY
Oliver from Google's Open Source Security team discusses the Open Source Vulnerability schema (OSV).

IDEAS
* OSV is a JSON schema for describing known vulnerabilities in open source packages.
* It aims to be minimal, community-maintained, easy to use, and comprehensive.
* The schema prioritizes core use cases, simplicity, correctness, and consistency.
* It focuses on enabling developers to identify and remediate vulnerabilities.
* OSV promotes a distributed model of home vulnerability databases.
* It supports extension points for database or ecosystem-specific metadata.
* Backwards compatibility is paramount; breaking changes are avoided.
* OSV provides reference tooling like osv.dev and OSV Scanner.
* These tools aid adoption and provide feedback for schema improvement.
* Future work includes addressing false positives and VEX applicability.
* Sharing and propagating VEX statements can reduce investigation time.
* A convention for storing intermediate VEX files could be beneficial.
* This would help determine and reduce investigation time for vulnerabilities.
* OSV aims to be actionable, focusing on developer needs and remediation.
* The schema enforces specific encoding and capitalization for consistency.
* It considers research use cases out of scope if they compromise main goals.
* OSV leverages upstream rules for relevant ecosystems and enforces them.
* Version ordering is handled according to ecosystem-specific rules.
* The schema distinguishes between strict SemVer and ecosystem-specific ordering.
* It provides pseudocode for version matching, including Git versioning.
* OSV avoids adding fields for proprietary software or non-actionable data.
* Timestamp ranges were rejected due to lack of actionability for scanners.
* Aliases enable cross-referencing with external metadata like EPSS and CISA.
* The schema facilitates corrections and changes through open-source practices.
* Reference tooling demonstrates OSV's functionality and encourages adoption.
* It helps gather feedback for both the schema and upstream data quality.
* OSV redirects users to upstream communities for new feed support.
* This encourages adoption of the OSV schema by those communities.

INSIGHTS
* A minimal schema design facilitates adoption and reduces complexity.
* Focusing on core use cases ensures actionability and avoids bloat.
* Consistency and correctness are crucial for automated vulnerability analysis.
* Ecosystem-specific rules are essential for accurate version matching.
* A distributed model empowers communities and aligns with open-source principles.
* Backwards compatibility is vital for long-term stability and adoption.
* Reference tooling provides practical demonstrations and feedback mechanisms.
* Sharing vulnerability investigation efforts can benefit the entire ecosystem.
* Clear communication and redirection encourage community participation.
* Prioritizing developer needs and remediation streamlines vulnerability management.

QUOTES
* "The emphasis here is on this being actionable with the recognition that software developers are often the ones at the receiving end of all vulnerability reports and are the ones being asked to resolve these issues." - Oliver
* "Each field should serve a distinct purpose directly linked to the core use cases." - Oliver
* "Aspirational fields which can't be realistically populated by databases nor realistically used by consumers must also be avoided." - Oliver
* "Aliases wouldn't work here because of his bundling. Aliases would mean that every single bundle CVE is the exact same which is incorrect." - Oliver
* "We generally consider these out of scope in that while we want to support these use cases, we wouldn't want to make any changes to support them that will compromise some of our main goals." - Oliver
* "So in a schema we distinguish between the strict SemVer ordering as defined by the SemVer 2.0 spec and ecosystem which refers to the specific rules for the relevant ecosystem." - Oliver
* "The main consideration here is that if a vulnerability scanner reported this result, it really wasn't clear to the user what they can do about it." - Oliver
* "What has been really important for us is to provide an end-to-end set of reference tooling that makes use of vulnerability feeds formatted in OSV." - Oliver
* "Providing tools and services on top of OSV data helps foster adoption because users can easily see how OSV works and how it could be integrated into their workflows." - Oliver
* "What we promise is that if you're a client targeting an older version of a schema, you can safely ignore any fields that you don't understand because you haven't updated your client to support the latest version." - Oliver

HABITS
* Prioritize core use cases when designing or making changes to systems.
* Focus on simplicity and minimalism in schema design and implementation.
* Enforce consistency and correctness in data formats and processes.
* Follow upstream rules and guidelines for relevant ecosystems.
* Provide clear and actionable information for users of tools and services.
* Avoid adding unnecessary or aspirational fields to schemas.
* Develop and maintain reference tooling to demonstrate functionality.
* Gather feedback from users and incorporate it into future iterations.
* Redirect users to appropriate upstream communities for specific issues.
* Maintain backwards compatibility to avoid breaking existing integrations.

FACTS
* There are almost 300,000 advisories collected across 31 ecosystems.
* OSV data is aggregated from 21 vulnerability databases.
* GitHub advisory database uses the GHSA- prefix for vulnerability IDs.
* Go vulnerability database uses the GO- prefix for vulnerability IDs.
* Ubuntu security notices are prefixed by USN and often bundle multiple CVEs.
* SemVer 2.0 spec defines clear rules for version precedence and ordering.
* Many ecosystems don't follow the strict SemVer versioning rules.
* OSV supports Git versioning schemes and non-linear version ranges.
* Maven ecosystem has complex rules for version ordering.
* OSV promotes a distributed model of home vulnerability databases.

REFERENCES
* JSON Schema
* OpenSSF
* Open Source Packages
* Linux Distributions
* SBOMs
* MVD
* CVE List
* Debian Ecosystem
* PyPI (Python) Ecosystem
* Maven Ecosystem
* SemVer 2.0 Spec
* Git
* OSV Schema
* osv.dev
* OSV Scanner
* GitHub Advisory Database
* Go Vulnerability Database
* RustSec Advisory Database
* CPEs
* EPSS
* CISA KEV
* VEX

ONE-SENTENCE TAKEAWAY
OSV simplifies vulnerability management by providing a consistent, actionable schema and fostering community collaboration.

RECOMMENDATIONS
* Adopt the OSV schema for describing vulnerabilities in open-source projects.
* Use OSV Scanner to identify vulnerabilities in your projects and dependencies.
* Contribute to OSV and upstream databases to improve data quality and coverage.
* Consider VEX applicability and propagation to reduce false positives.
* Explore conventions for storing and sharing intermediate VEX statements.
* Prioritize actionable information and clear remediation steps for developers.
* Focus on core use cases and avoid adding unnecessary complexity to schemas.
* Follow ecosystem-specific rules for versioning and dependency management.
* Leverage existing tooling and resources to streamline vulnerability workflows.
* Engage with open-source communities to foster collaboration and adoption.
* Maintain backwards compatibility when updating schemas or tools.
* Use aliases to cross-reference OSV records with external metadata.
* Provide extension points for database or ecosystem-specific information.
* Develop and maintain reference tooling to demonstrate best practices.
* Gather feedback from users and incorporate it into future development.
