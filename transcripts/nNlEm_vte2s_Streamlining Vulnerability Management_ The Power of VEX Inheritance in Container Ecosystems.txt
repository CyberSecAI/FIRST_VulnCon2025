Kind: captions Language: en Hi, my name is God. I've uh been at Hi, my name is God. I've uh been at Hi, my name is God. I've uh been at Nvidia for about three years and I also Nvidia for about three years and I also Nvidia for about three years and I also work on the product security tools work on the product security tools work on the product security tools team. All right, we're going to talk team. All right, we're going to talk team. All right, we're going to talk about streamlining container security about streamlining container security about streamlining container security and how to get VEX in the right place so and how to get VEX in the right place so and how to get VEX in the right place so you don't have to redo it over and over you don't have to redo it over and over you don't have to redo it over and over and over again for all of the different products. Okay. Um, so we actually products. Okay. Um, so we actually products. Okay. Um, so we actually talked last year about a really similar talked last year about a really similar talked last year about a really similar topic, VEX inheritance. And we, so since topic, VEX inheritance. And we, so since topic, VEX inheritance. And we, so since October of 23, um, Nvidia has been October of 23, um, Nvidia has been October of 23, um, Nvidia has been publishing VEX for the NVIDIA AI publishing VEX for the NVIDIA AI publishing VEX for the NVIDIA AI enterprise container images that are enterprise container images that are enterprise container images that are published on the NGC catalog. And so we published on the NGC catalog. And so we published on the NGC catalog. And so we created tooling back in 23 for syncing created tooling back in 23 for syncing created tooling back in 23 for syncing all of the OSS vulnerability reports and all of the OSS vulnerability reports and all of the OSS vulnerability reports and then having the ability then to put in then having the ability then to put in then having the ability then to put in the the VEX status and justification and the the VEX status and justification and the the VEX status and justification and details get that reviewed and we have an details get that reviewed and we have an details get that reviewed and we have an approval process through that tooling approval process through that tooling approval process through that tooling and then we actually have a publishing and then we actually have a publishing and then we actually have a publishing process as well. So when that container process as well. So when that container process as well. So when that container image gets published then the the image gets published then the the image gets published then the the publishing pipeline calls the um the VEX publishing pipeline calls the um the VEX publishing pipeline calls the um the VEX tooling and publishes the VEX in Cyclone tooling and publishes the VEX in Cyclone tooling and publishes the VEX in Cyclone DX format on the NGC catalog. So that DX format on the NGC catalog. So that DX format on the NGC catalog. So that was all back in 23. um we had a very was all back in 23. um we had a very was all back in 23. um we had a very small subset that we started the the VEX small subset that we started the the VEX small subset that we started the the VEX publishing process with um but we soon publishing process with um but we soon publishing process with um but we soon found that hey we were writing the same found that hey we were writing the same found that hey we were writing the same VEX over and over and over again um for VEX over and over and over again um for VEX over and over and over again um for one the same actual like release right one the same actual like release right one the same actual like release right like let's say you do a build you get a like let's say you do a build you get a like let's say you do a build you get a container image we had no way to say container image we had no way to say container image we had no way to say that this container image is the same um that this container image is the same um that this container image is the same um product as the next container image um product as the next container image um product as the next container image um but it's just like we're still working but it's just like we're still working but it's just like we're still working on the same release so we had this idea on the same release so we had this idea on the same release so we had this idea a of we'll tell the product teams to use a of we'll tell the product teams to use a of we'll tell the product teams to use a tagging schema that will allow us to a tagging schema that will allow us to a tagging schema that will allow us to inherit the VEX that's been approved inherit the VEX that's been approved inherit the VEX that's been approved between the releases from one build to between the releases from one build to between the releases from one build to the next. And then similarly, we had an the next. And then similarly, we had an the next. And then similarly, we had an idea to copy or clone the VEX from one idea to copy or clone the VEX from one idea to copy or clone the VEX from one release to the other um with the similar release to the other um with the similar release to the other um with the similar like tagging schema. We went back to the like tagging schema. We went back to the like tagging schema. We went back to the product teams and they were like, "Yeah, product teams and they were like, "Yeah, product teams and they were like, "Yeah, no, we don't ever actually use the same no, we don't ever actually use the same no, we don't ever actually use the same tag. We use um like a commit shaw for tag. We use um like a commit shaw for tag. We use um like a commit shaw for our tag." And so we then determine which our tag." And so we then determine which our tag." And so we then determine which one is the release candidate and you one is the release candidate and you one is the release candidate and you have no idea which one came first and have no idea which one came first and have no idea which one came first and which one came later based on the tag. which one came later based on the tag. which one came later based on the tag. Um so we've come up with some new Um so we've come up with some new Um so we've come up with some new ideas. Um so we will talk about VEX ideas. Um so we will talk about VEX ideas. Um so we will talk about VEX inheritance. We'll talk about another inheritance. We'll talk about another inheritance. We'll talk about another concept that we've coined global VEX. Um concept that we've coined global VEX. Um concept that we've coined global VEX. Um and then we will give you some proposed and then we will give you some proposed and then we will give you some proposed approach that that we worked on design approach that that we worked on design approach that that we worked on design earlier in 2024. How we implemented some earlier in 2024. How we implemented some earlier in 2024. How we implemented some of that and then some of the limitations of that and then some of the limitations of that and then some of the limitations and some of the lessons learned that we and some of the lessons learned that we and some of the lessons learned that we came across. Um yeah so the complexity here right is Um yeah so the complexity here right is Um yeah so the complexity here right is that it's really difficult to determine that it's really difficult to determine that it's really difficult to determine from one container image build to the from one container image build to the from one container image build to the next next next um you know that that is the lineage um you know that that is the lineage um you know that that is the lineage from one to the next right that the the from one to the next right that the the from one to the next right that the the vulnerability analysis should apply for vulnerability analysis should apply for vulnerability analysis should apply for all of those. Um and so we have these all of those. Um and so we have these all of those. Um and so we have these two terms here. VEX inheritance which we two terms here. VEX inheritance which we two terms here. VEX inheritance which we are using to state that when we have a are using to state that when we have a are using to state that when we have a parent image and parent image in this parent image and parent image in this parent image and parent image in this case is any any image in the lineage of case is any any image in the lineage of case is any any image in the lineage of your final image. um you should be able your final image. um you should be able your final image. um you should be able to determine what the vulnerability to determine what the vulnerability to determine what the vulnerability analysis is in many cases for that analysis is in many cases for that analysis is in many cases for that parent image and inherit that to the parent image and inherit that to the parent image and inherit that to the final image so that during the release final image so that during the release final image so that during the release of your final image you have already of your final image you have already of your final image you have already done a lot of the analysis for the done a lot of the analysis for the done a lot of the analysis for the parent image for both the OSS licensing parent image for both the OSS licensing parent image for both the OSS licensing and also the the vulnerability details and also the the vulnerability details and also the the vulnerability details and you should be able to do a diff on and you should be able to do a diff on and you should be able to do a diff on if the parent image and the final image if the parent image and the final image if the parent image and the final image have the exact same sbomb or the same have the exact same sbomb or the same have the exact same sbomb or the same list of oss packages and the same list of oss packages and the same list of oss packages and the same vulnerabilities. ities and then inherit vulnerabilities. ities and then inherit vulnerabilities. ities and then inherit in most cases those those in most cases those those in most cases those those vexs. The other concept here is the vexs. The other concept here is the vexs. The other concept here is the global vex. This is where we are using global vex. This is where we are using global vex. This is where we are using um a policy to define in our scanning um a policy to define in our scanning um a policy to define in our scanning tooling our scan our tooling scan tooling our scan our tooling scan tooling our scan our tooling scan tooling the the when we find tooling the the when we find tooling the the when we find the opensource patched versions. So the opensource patched versions. So the opensource patched versions. So these custom versions, right? Like we these custom versions, right? Like we these custom versions, right? Like we took the open source, we forked it, we took the open source, we forked it, we took the open source, we forked it, we actually patched something. And so now actually patched something. And so now actually patched something. And so now we're naming the open source. Basically, we're naming the open source. Basically, we're naming the open source. Basically, it's the same version, but it's like it's the same version, but it's like it's the same version, but it's like dash we fixed this, right? And we can dash we fixed this, right? And we can dash we fixed this, right? And we can map the vulnerability details that we map the vulnerability details that we map the vulnerability details that we fixed in that patched version. add it to fixed in that patched version. add it to fixed in that patched version. add it to this policy detect that whenever we're this policy detect that whenever we're this policy detect that whenever we're scanning the container image and scanning the container image and scanning the container image and anywhere we see that custom SCA uh anywhere we see that custom SCA uh anywhere we see that custom SCA uh custom OSS version then we should be custom OSS version then we should be custom OSS version then we should be able to apply that patched vex status. able to apply that patched vex status. able to apply that patched vex status. So that allows us to do this across the So that allows us to do this across the So that allows us to do this across the board wherever we're using those patched board wherever we're using those patched board wherever we're using those patched versions. That's the global vex term versions. That's the global vex term versions. That's the global vex term here for VEX inheritance. The key steps here for VEX inheritance. The key steps here for VEX inheritance. The key steps really are we want to catalog the really are we want to catalog the really are we want to catalog the approved parent images. And the parent approved parent images. And the parent approved parent images. And the parent image in this case is really the largest image in this case is really the largest image in this case is really the largest subset of open source that is reusable subset of open source that is reusable subset of open source that is reusable or sharable among multiple applications. or sharable among multiple applications. or sharable among multiple applications. So that's kind of what we're trying to So that's kind of what we're trying to So that's kind of what we're trying to get to at the the parent image. Um, we get to at the the parent image. Um, we get to at the the parent image. Um, we add these to our catalog with a specific add these to our catalog with a specific add these to our catalog with a specific use case because those approved parent use case because those approved parent use case because those approved parent images, we want to make sure that we images, we want to make sure that we images, we want to make sure that we know which use cases that those are know which use cases that those are know which use cases that those are approved for and which application approved for and which application approved for and which application groups those are approved for. Then groups those are approved for. Then groups those are approved for. Then after they are added to the approved after they are added to the approved after they are added to the approved parent image registry, then we can look parent image registry, then we can look parent image registry, then we can look at the vulnerability details. We can at the vulnerability details. We can at the vulnerability details. We can associate any VEX. We can go through any associate any VEX. We can go through any associate any VEX. We can go through any license approval process we need to and license approval process we need to and license approval process we need to and associate those to the parent image. associate those to the parent image. associate those to the parent image. Once we have the final image built and Once we have the final image built and Once we have the final image built and we do the scan on that final image, we we do the scan on that final image, we we do the scan on that final image, we get an SBOM for the final image. We can get an SBOM for the final image. We can get an SBOM for the final image. We can also detect which parent image it was also detect which parent image it was also detect which parent image it was built upon. And then we can do a diff. built upon. And then we can do a diff. built upon. And then we can do a diff. So we can say here's the Sbomb of the So we can say here's the Sbomb of the So we can say here's the Sbomb of the parent image. Here's the sbomb of the parent image. Here's the sbomb of the parent image. Here's the sbomb of the final image and determine the difference final image and determine the difference final image and determine the difference of those open- source packages and of those open- source packages and of those open- source packages and vulnerabilities. And you only have to vulnerabilities. And you only have to vulnerabilities. And you only have to then go through that analysis before you then go through that analysis before you then go through that analysis before you can release. So the goal is to cut down can release. So the goal is to cut down can release. So the goal is to cut down on how quickly or how much work you need on how quickly or how much work you need on how quickly or how much work you need to do for release for each of those to do for release for each of those to do for release for each of those final images. images. images. Um I talked about the approved parent Um I talked about the approved parent Um I talked about the approved parent image being anywhere in that lineage. So image being anywhere in that lineage. So image being anywhere in that lineage. So that's kind of what this uh image is that's kind of what this uh image is that's kind of what this uh image is trying to talk about. It does not have trying to talk about. It does not have trying to talk about. It does not have to be the initial base image of that to be the initial base image of that to be the initial base image of that final image. Right? We know that we have final image. Right? We know that we have final image. Right? We know that we have a base image. You could build something a base image. You could build something a base image. You could build something on top of that. You could add in open on top of that. You could add in open on top of that. You could add in open source packages. You could take that source packages. You could take that source packages. You could take that next layer, that parent image number one next layer, that parent image number one next layer, that parent image number one there. Um, we could add in some Nvidia there. Um, we could add in some Nvidia there. Um, we could add in some Nvidia proprietary um, libraries there. Then a proprietary um, libraries there. Then a proprietary um, libraries there. Then a product team could say, "Oh, and I need product team could say, "Oh, and I need product team could say, "Oh, and I need some other libraries." So they'll create some other libraries." So they'll create some other libraries." So they'll create another uh, layer, another parent image another uh, layer, another parent image another uh, layer, another parent image on top of that one. We really want to on top of that one. We really want to on top of that one. We really want to get to, like I said, the the largest get to, like I said, the the largest get to, like I said, the the largest common set of open-source so that we can common set of open-source so that we can common set of open-source so that we can set that as a use case, take that set that as a use case, take that set that as a use case, take that through any of the compliance um tasks through any of the compliance um tasks through any of the compliance um tasks and the vulnerability analysis and then and the vulnerability analysis and then and the vulnerability analysis and then we can share that across all of those we can share that across all of those we can share that across all of those applications that end up using that applications that end up using that applications that end up using that parent image. It's important to define parent image. It's important to define parent image. It's important to define ownership of those approved parent ownership of those approved parent ownership of those approved parent images because somebody needs to images because somebody needs to images because somebody needs to maintain these, right? when there are maintain these, right? when there are maintain these, right? when there are new vulnerabilities found, we need to be new vulnerabilities found, we need to be new vulnerabilities found, we need to be able to uh analyze that and add in more able to uh analyze that and add in more able to uh analyze that and add in more VEX or we may need to say, hey, you can VEX or we may need to say, hey, you can VEX or we may need to say, hey, you can no longer use that approved parent no longer use that approved parent no longer use that approved parent image. It is now not valid for use. You image. It is now not valid for use. You image. It is now not valid for use. You have to use the upgraded apparent have to use the upgraded apparent have to use the upgraded apparent approved parent image. And so we do have approved parent image. And so we do have approved parent image. And so we do have that tracking built into our catalog as that tracking built into our catalog as that tracking built into our catalog as well. We have like an expiration date. well. We have like an expiration date. well. We have like an expiration date. So you could set that whenever one So you could set that whenever one So you could set that whenever one approved parent image is no longer um approved parent image is no longer um approved parent image is no longer um valid for use. Um so Jessica mentioned this earlier but Um so Jessica mentioned this earlier but Um so Jessica mentioned this earlier but we have um coined a term called global we have um coined a term called global we have um coined a term called global vex within our vex within our vex within our um we have coined a term called global um we have coined a term called global um we have coined a term called global vex within our vex within our vex within our um uh container scanning workflow. So um um uh container scanning workflow. So um um uh container scanning workflow. So um global vex is a way for us to globally global vex is a way for us to globally global vex is a way for us to globally generate and apply vex documents for oss generate and apply vex documents for oss generate and apply vex documents for oss patches either from internal patches either from internal patches either from internal developments or from thirdparty um developments or from thirdparty um developments or from thirdparty um partnerships that we have with other partnerships that we have with other partnerships that we have with other vendors. And so this allows us to manage vendors. And so this allows us to manage vendors. And so this allows us to manage the usage of these um private oss the usage of these um private oss the usage of these um private oss packages I mean oss patches. Um so this packages I mean oss patches. Um so this packages I mean oss patches. Um so this includes automating the detection of the includes automating the detection of the includes automating the detection of the oss packages I mean sorry oss patches uh oss packages I mean sorry oss patches uh oss packages I mean sorry oss patches uh generating the vex documents um and then generating the vex documents um and then generating the vex documents um and then applying the vex to the reports so that applying the vex to the reports so that applying the vex to the reports so that um whatever the um the patches that are um whatever the um the patches that are um whatever the um the patches that are used we uh just filter those out um from used we uh just filter those out um from used we uh just filter those out um from the vulnerability reports to reduce the the vulnerability reports to reduce the the vulnerability reports to reduce the noise. Um we also have a way to use the noise. Um we also have a way to use the noise. Um we also have a way to use the global vex to provide upgrade guidance global vex to provide upgrade guidance global vex to provide upgrade guidance to teams. So whenever the patches do to teams. So whenever the patches do to teams. So whenever the patches do become ava a available um we can enhance become ava a available um we can enhance become ava a available um we can enhance the visibility and streamline the the visibility and streamline the the visibility and streamline the adoption of the internally available adoption of the internally available adoption of the internally available patch software so that um developers patch software so that um developers patch software so that um developers that could be like trying to mitigate a that could be like trying to mitigate a that could be like trying to mitigate a vulnerability they would know that there vulnerability they would know that there vulnerability they would know that there is a patched version available either is a patched version available either is a patched version available either from a vendor or internally developed. from a vendor or internally developed. from a vendor or internally developed. So this really helps to reduce the noise So this really helps to reduce the noise So this really helps to reduce the noise and streamline um how we can globally and streamline um how we can globally and streamline um how we can globally manage these patched versions. Okay, hopefully you can follow versions. Okay, hopefully you can follow versions. Okay, hopefully you can follow the picture. Um, but I wanted to walk the picture. Um, but I wanted to walk the picture. Um, but I wanted to walk through kind of how our product catalog, through kind of how our product catalog, through kind of how our product catalog, our scanning infrastructure, and then our scanning infrastructure, and then our scanning infrastructure, and then our VEX tooling um, work together to our VEX tooling um, work together to our VEX tooling um, work together to allow us to register the parent images allow us to register the parent images allow us to register the parent images and then where there are people here at and then where there are people here at and then where there are people here at play. So, a user or API would register play. So, a user or API would register play. So, a user or API would register that parent image. We add it into the that parent image. We add it into the that parent image. We add it into the the parent image registry uh, using a the parent image registry uh, using a the parent image registry uh, using a ticketing workflow today. And then the ticketing workflow today. And then the ticketing workflow today. And then the the the image as soon as it's registered the the image as soon as it's registered the the image as soon as it's registered will go through scanning. So you see will go through scanning. So you see will go through scanning. So you see that number two down here to the that number two down here to the that number two down here to the container scanning infrastructure. The container scanning infrastructure. The container scanning infrastructure. The um the container scanning infrastructure um the container scanning infrastructure um the container scanning infrastructure updates reports in the product catalog. updates reports in the product catalog. updates reports in the product catalog. Those reports will generate license Those reports will generate license Those reports will generate license reports and we'll generate vulnerability reports and we'll generate vulnerability reports and we'll generate vulnerability reports. And so the license reports can reports. And so the license reports can reports. And so the license reports can be used to create the OSS license be used to create the OSS license be used to create the OSS license ticketing process. So this is where our ticketing process. So this is where our ticketing process. So this is where our review board at NVIDIA will review all review board at NVIDIA will review all review board at NVIDIA will review all of the OSS licenses that are going into of the OSS licenses that are going into of the OSS licenses that are going into that product. Then you can also go into that product. Then you can also go into that product. Then you can also go into the you can view the vulnerability the you can view the vulnerability the you can view the vulnerability reports in the product catalog and then reports in the product catalog and then reports in the product catalog and then you can go into the VEX tooling to you can go into the VEX tooling to you can go into the VEX tooling to actually add in any analysis for the actually add in any analysis for the actually add in any analysis for the vulnerabilities and have that get vulnerabilities and have that get vulnerabilities and have that get submitted for a review approval process submitted for a review approval process submitted for a review approval process as well. So none of the VEX are ready to as well. So none of the VEX are ready to as well. So none of the VEX are ready to publish until they get approved by the publish until they get approved by the publish until they get approved by the product owner of um of the right now the product owner of um of the right now the product owner of um of the right now the AI enterprise catalog. So they go AI enterprise catalog. So they go AI enterprise catalog. So they go through the VEX tooling. They can then through the VEX tooling. They can then through the VEX tooling. They can then go back to the reports and they can see go back to the reports and they can see go back to the reports and they can see that the vulnerabilities that have that the vulnerabilities that have that the vulnerabilities that have approved VEX will fall off of the approved VEX will fall off of the approved VEX will fall off of the priority list and they now get added to priority list and they now get added to priority list and they now get added to a different report for the VEX list. The a different report for the VEX list. The a different report for the VEX list. The OSRB ticket, the open-source review OSRB ticket, the open-source review OSRB ticket, the open-source review board ticket is also tracked in the board ticket is also tracked in the board ticket is also tracked in the product catalog and it notes that product catalog and it notes that product catalog and it notes that exactly the ESBOM for that parent exactly the ESBOM for that parent exactly the ESBOM for that parent image. So we now have tracking on what image. So we now have tracking on what image. So we now have tracking on what was approved in terms of the ESBOM, all was approved in terms of the ESBOM, all was approved in terms of the ESBOM, all of the OSS and what vulnerabilities were of the OSS and what vulnerabilities were of the OSS and what vulnerabilities were approved for that parent image. Next we approved for that parent image. Next we approved for that parent image. Next we register a final image. Um and in both register a final image. Um and in both register a final image. Um and in both cases right we have this like concept of cases right we have this like concept of cases right we have this like concept of a use case for the parent image and the a use case for the parent image and the a use case for the parent image and the use case must match for the must match use case must match for the must match use case must match for the must match for the final image as well. So you for the final image as well. So you for the final image as well. So you register the final image it gets scanned register the final image it gets scanned register the final image it gets scanned using that same container scanning using that same container scanning using that same container scanning infrastructure. Um this time though it infrastructure. Um this time though it infrastructure. Um this time though it will also look to see if it has a will also look to see if it has a will also look to see if it has a approved parent image in that list from approved parent image in that list from approved parent image in that list from that use case. So it will check to see that use case. So it will check to see that use case. So it will check to see if it has a compliant approved parent if it has a compliant approved parent if it has a compliant approved parent image. If it does, then it will show image. If it does, then it will show image. If it does, then it will show that in the reports. It's using this that in the reports. It's using this that in the reports. It's using this approved parent image. And it will also approved parent image. And it will also approved parent image. And it will also create a sbomb comparison between the create a sbomb comparison between the create a sbomb comparison between the parent image and the final image. So you parent image and the final image. So you parent image and the final image. So you can see any open source that was added can see any open source that was added can see any open source that was added on top of that parent image. You can on top of that parent image. You can on top of that parent image. You can then take that subset of open- source then take that subset of open- source then take that subset of open- source packages and licenses to the review packages and licenses to the review packages and licenses to the review board. So they can look at a much board. So they can look at a much board. So they can look at a much smaller list of licenses for compliance. smaller list of licenses for compliance. smaller list of licenses for compliance. or if there is no uh extra open source or if there is no uh extra open source or if there is no uh extra open source added to the parent image, then it does added to the parent image, then it does added to the parent image, then it does not need to go through the review board not need to go through the review board not need to go through the review board and so they'll get an automatic approval and so they'll get an automatic approval and so they'll get an automatic approval for the OSRB ticketing process. So that for the OSRB ticketing process. So that for the OSRB ticketing process. So that part of the release is checked and ready part of the release is checked and ready part of the release is checked and ready to go. For vulnerabilities, again, if to go. For vulnerabilities, again, if to go. For vulnerabilities, again, if there's no new open source, there's there's no new open source, there's there's no new open source, there's likely no new vulnerabilities, although likely no new vulnerabilities, although likely no new vulnerabilities, although there could be a new one published, and there could be a new one published, and there could be a new one published, and then you should actually go back to the then you should actually go back to the then you should actually go back to the parent image and add the VEX there. But parent image and add the VEX there. But parent image and add the VEX there. But if there's no um new vulnerabilities and if there's no um new vulnerabilities and if there's no um new vulnerabilities and they get a check for that part of the they get a check for that part of the they get a check for that part of the release process as well. If there is new release process as well. If there is new release process as well. If there is new oss and there are vulnerabilities oss and there are vulnerabilities oss and there are vulnerabilities associated there then they will just see associated there then they will just see associated there then they will just see the difference between the the difference between the the difference between the vulnerabilities that have already been vulnerabilities that have already been vulnerabilities that have already been vexed and the vulnerabilities that need vexed and the vulnerabilities that need vexed and the vulnerabilities that need their analysis. They can go to the VEX their analysis. They can go to the VEX their analysis. They can go to the VEX tooling and add in the analysis for tooling and add in the analysis for tooling and add in the analysis for that. So once the approved parent images are So once the approved parent images are So once the approved parent images are registered in the product catalog, the registered in the product catalog, the registered in the product catalog, the next part of it is to actually shift next part of it is to actually shift next part of it is to actually shift compliance left and provide in pipeline compliance left and provide in pipeline compliance left and provide in pipeline scanning and and detection. So before scanning and and detection. So before scanning and and detection. So before build um developers are encouraged to build um developers are encouraged to build um developers are encouraged to use the product catalog to find um use the product catalog to find um use the product catalog to find um approved parent images that match their approved parent images that match their approved parent images that match their use case. the um in pipeline jobs are use case. the um in pipeline jobs are use case. the um in pipeline jobs are enabled to detect the parent image by enabled to detect the parent image by enabled to detect the parent image by use case, determine if the parent image use case, determine if the parent image use case, determine if the parent image is approved for that use case and then is approved for that use case and then is approved for that use case and then if it is approved, it can uh apply the if it is approved, it can uh apply the if it is approved, it can uh apply the parent image vex on top of the container parent image vex on top of the container parent image vex on top of the container scan uh vulnerability reports. So the scan uh vulnerability reports. So the scan uh vulnerability reports. So the reports um that are provided to the de reports um that are provided to the de reports um that are provided to the de to the developer in pipeline um tell the to the developer in pipeline um tell the to the developer in pipeline um tell the developer if it's using an approved developer if it's using an approved developer if it's using an approved parent image and um it provides only the parent image and um it provides only the parent image and um it provides only the vulnerabilities that need to be triaged vulnerabilities that need to be triaged vulnerabilities that need to be triaged that are not um coming from the parent that are not um coming from the parent that are not um coming from the parent image. image. image. Um so these jobs can also be used um to Um so these jobs can also be used um to Um so these jobs can also be used um to block pipelines for example if maybe block pipelines for example if maybe block pipelines for example if maybe they aren't using compliant parent they aren't using compliant parent they aren't using compliant parent images and um kind of just shift this um images and um kind of just shift this um images and um kind of just shift this um these features left and start in the these features left and start in the these features left and start in the pipeline. Um so throughout this process we have Um so throughout this process we have Um so throughout this process we have found some limitations with the found some limitations with the found some limitations with the automated um parent image detection. So automated um parent image detection. So automated um parent image detection. So the way that the automated parent image the way that the automated parent image the way that the automated parent image detection works is that it uses the detection works is that it uses the detection works is that it uses the image layers between the parent image image layers between the parent image image layers between the parent image and the final image and it will try to and the final image and it will try to and the final image and it will try to match um those layers and so if all of match um those layers and so if all of match um those layers and so if all of the parent image layers are found in the the parent image layers are found in the the parent image layers are found in the final image then that is how a parent final image then that is how a parent final image then that is how a parent image is image is image is determined. Um so while this process um determined. Um so while this process um determined. Um so while this process um does work sometimes we have seen that um does work sometimes we have seen that um does work sometimes we have seen that um there are cases where we use um we we there are cases where we use um we we there are cases where we use um we we use tools like registry operation tools use tools like registry operation tools use tools like registry operation tools like scopio or crane. These are both like scopio or crane. These are both like scopio or crane. These are both open source tools. Um, and these tools open source tools. Um, and these tools open source tools. Um, and these tools provide metadata on the image like the provide metadata on the image like the provide metadata on the image like the image layer digest, uh, the size, the image layer digest, uh, the size, the image layer digest, uh, the size, the architecture, um, all without requiring architecture, um, all without requiring architecture, um, all without requiring a Docker demon to be present. And so a Docker demon to be present. And so a Docker demon to be present. And so these tools are very quick at doing this these tools are very quick at doing this these tools are very quick at doing this image metadata analysis. However, we image metadata analysis. However, we image metadata analysis. However, we have found that there are cases where have found that there are cases where have found that there are cases where the detection can be unreliable based on the detection can be unreliable based on the detection can be unreliable based on um, varying registry storage mechanisms um, varying registry storage mechanisms um, varying registry storage mechanisms such as the compression algorithms used such as the compression algorithms used such as the compression algorithms used by the registry. So in order to address by the registry. So in order to address by the registry. So in order to address these issues, we also recommend these issues, we also recommend these issues, we also recommend integrating the build configuration um integrating the build configuration um integrating the build configuration um explicitly to provide the apparent image explicitly to provide the apparent image explicitly to provide the apparent image details. So um kind of going to our back details. So um kind of going to our back details. So um kind of going to our back to our to our to our pipeline diagram um in cases where the pipeline diagram um in cases where the pipeline diagram um in cases where the detection fails, we also can ingest the detection fails, we also can ingest the detection fails, we also can ingest the parent image used in the image build parent image used in the image build parent image used in the image build configuration um as part of the pipeline configuration um as part of the pipeline configuration um as part of the pipeline flow. So in these cases we really want flow. So in these cases we really want flow. So in these cases we really want to ensure that um the bu the parent to ensure that um the bu the parent to ensure that um the bu the parent image configuration used is actually image configuration used is actually image configuration used is actually being used to build the final image. So being used to build the final image. So being used to build the final image. So um this can be done either through um this can be done either through um this can be done either through docker file scanning to find that last docker file scanning to find that last docker file scanning to find that last parent image or this um lineage of parent image or this um lineage of parent image or this um lineage of parent images used or it can be done parent images used or it can be done parent images used or it can be done through like a custom build through like a custom build through like a custom build configuration if there is a like a configuration if there is a like a configuration if there is a like a custom build process that's used to um custom build process that's used to um custom build process that's used to um do the build for the final image. And do the build for the final image. And do the build for the final image. And then we continue on to the same process then we continue on to the same process then we continue on to the same process of checking if the parent image is of checking if the parent image is of checking if the parent image is approved. if it is approved applying the approved. if it is approved applying the approved. if it is approved applying the parent image vex and then um we also parent image vex and then um we also parent image vex and then um we also will cache the parent images in the will cache the parent images in the will cache the parent images in the final image association in our product final image association in our product final image association in our product catalog. So when it does come time for catalog. So when it does come time for catalog. So when it does come time for release we don't just have this release we don't just have this release we don't just have this information in our pipeline but we also information in our pipeline but we also information in our pipeline but we also have it available in our product catalog have it available in our product catalog have it available in our product catalog and we can um enable the sbomb and we can um enable the sbomb and we can um enable the sbomb difference and the license approvals um difference and the license approvals um difference and the license approvals um at that time as well. So we have added in the ability to when So we have added in the ability to when So we have added in the ability to when you're detecting the sbomb diff know if you're detecting the sbomb diff know if you're detecting the sbomb diff know if an oss package was added in that in the an oss package was added in that in the an oss package was added in that in the other layer right like if that oss other layer right like if that oss other layer right like if that oss package came from the final layer or package came from the final layer or package came from the final layer or from the parent um image and which one from the parent um image and which one from the parent um image and which one of those the vulnerability was of those the vulnerability was of those the vulnerability was associated to so if the vulnerability associated to so if the vulnerability associated to so if the vulnerability was associated to the parent image then was associated to the parent image then was associated to the parent image then we can inherit in most cases the vex for we can inherit in most cases the vex for we can inherit in most cases the vex for that we don't want to inherit at the that we don't want to inherit at the that we don't want to inherit at the vulner the vex details for a vulner the vex details for a vulner the vex details for a vulnerability that was also added in the vulnerability that was also added in the vulnerability that was also added in the final image because we're not sure if final image because we're not sure if final image because we're not sure if that had the right analysis applied to that had the right analysis applied to that had the right analysis applied to it. But there are other cases as well um it. But there are other cases as well um it. But there are other cases as well um that you want to kind of review before that you want to kind of review before that you want to kind of review before publishing these vex status um like a publishing these vex status um like a publishing these vex status um like a lot of these are the not affected lot of these are the not affected lot of these are the not affected mitigation ones. So if something mitigation ones. So if something mitigation ones. So if something requires configuration, you just want requires configuration, you just want requires configuration, you just want somebody to review that the somebody to review that the somebody to review that the configuration has not changed in that configuration has not changed in that configuration has not changed in that final image any that would now make that final image any that would now make that final image any that would now make that vulnerability exploitable. Similar with vulnerability exploitable. Similar with vulnerability exploitable. Similar with the dependency and with environment. So the dependency and with environment. So the dependency and with environment. So we're working on trying to add in more we're working on trying to add in more we're working on trying to add in more details that then we can detect as we details that then we can detect as we details that then we can detect as we are um you know rolling out or building are um you know rolling out or building are um you know rolling out or building that final image to make sure that we that final image to make sure that we that final image to make sure that we don't need to change these spec status. So some of the lessons learned, we did So some of the lessons learned, we did So some of the lessons learned, we did actually pilot this in November of 2024. actually pilot this in November of 2024. actually pilot this in November of 2024. So this has been live for um one of our So this has been live for um one of our So this has been live for um one of our first like our first product since then. first like our first product since then. first like our first product since then. Um one of the big things we learned is Um one of the big things we learned is Um one of the big things we learned is that there was not really a great that there was not really a great that there was not really a great definition of who was going to maintain definition of who was going to maintain definition of who was going to maintain the parent images. So the we were a part the parent images. So the we were a part the parent images. So the we were a part of the core product security team and of the core product security team and of the core product security team and when we told the product team hey we're when we told the product team hey we're when we told the product team hey we're going to give you this great feature going to give you this great feature going to give you this great feature they were like great that means you're they were like great that means you're they were like great that means you're going to manage all of our parent images going to manage all of our parent images going to manage all of our parent images and we were like no actually we're and we were like no actually we're and we were like no actually we're not we're going to detect them we still not we're going to detect them we still not we're going to detect them we still need you to maintain them and make sure need you to maintain them and make sure need you to maintain them and make sure that they work for your application. Um that they work for your application. Um that they work for your application. Um so there was a little bit of a hiccup so there was a little bit of a hiccup so there was a little bit of a hiccup there. So, we're still kind of working there. So, we're still kind of working there. So, we're still kind of working with the product team to make sure that with the product team to make sure that with the product team to make sure that they have owners on their side for all they have owners on their side for all they have owners on their side for all of those parent images and that they are of those parent images and that they are of those parent images and that they are making sure to keep those up to date, making sure to keep those up to date, making sure to keep those up to date, test um and do any sort of release test um and do any sort of release test um and do any sort of release cadence uh that is necessary. Again, cadence uh that is necessary. Again, cadence uh that is necessary. Again, that parent image is the largest common that parent image is the largest common that parent image is the largest common set of open source that's sharable set of open source that's sharable set of open source that's sharable between multiple releases, multiple between multiple releases, multiple between multiple releases, multiple products. And so, it really makes sense, products. And so, it really makes sense, products. And so, it really makes sense, right, that the product team owns that right, that the product team owns that right, that the product team owns that so they can make sure that they're so they can make sure that they're so they can make sure that they're testing it in the use case that they testing it in the use case that they testing it in the use case that they need it for. need it for. need it for. Um let's see. I think I hit all that. Um let's see. I think I hit all that. Um let's see. I think I hit all that. Next steps. Yeah. So we definitely want Next steps. Yeah. So we definitely want Next steps. Yeah. So we definitely want to do more automation. We have found to do more automation. We have found to do more automation. We have found that there that there that there are a big sub like a big subset of the are a big sub like a big subset of the are a big sub like a big subset of the approved parent images are actually approved parent images are actually approved parent images are actually images that our company already releases images that our company already releases images that our company already releases as core um AI enterprise images. And so as core um AI enterprise images. And so as core um AI enterprise images. And so those are used in some more of our those are used in some more of our those are used in some more of our products. Um those get released and products. Um those get released and products. Um those get released and patched already on a monthly basis. And patched already on a monthly basis. And patched already on a monthly basis. And today there's this ticketing process today there's this ticketing process today there's this ticketing process that requires the team to go through to that requires the team to go through to that requires the team to go through to say, "Hey, I've got a new release of say, "Hey, I've got a new release of say, "Hey, I've got a new release of this parent image. Please add it and the this parent image. Please add it and the this parent image. Please add it and the digest of that parent image to the tool digest of that parent image to the tool digest of that parent image to the tool so that it can be used as a compliant so that it can be used as a compliant so that it can be used as a compliant parent image." And we need to figure out parent image." And we need to figure out parent image." And we need to figure out a way, can we automate adding in those a way, can we automate adding in those a way, can we automate adding in those new releases of these parent images? We new releases of these parent images? We new releases of these parent images? We have not found a great way to do that have not found a great way to do that have not found a great way to do that yet. The global vex mappings. So today yet. The global vex mappings. So today yet. The global vex mappings. So today we get a list of VEX details from a we get a list of VEX details from a we get a list of VEX details from a vendor that says this o open- source vendor that says this o open- source vendor that says this o open- source package with this new version, this package with this new version, this package with this new version, this custom version has this vulnerability custom version has this vulnerability custom version has this vulnerability patched and we have to have somebody patched and we have to have somebody patched and we have to have somebody manually go and add this to one of our manually go and add this to one of our manually go and add this to one of our policies, the scan policy that then we policies, the scan policy that then we policies, the scan policy that then we do post-processing on that will automate do post-processing on that will automate do post-processing on that will automate creating the VEX for that package creating the VEX for that package creating the VEX for that package version vulnerability combination. And version vulnerability combination. And version vulnerability combination. And so we'd love a way to ingest that and so we'd love a way to ingest that and so we'd love a way to ingest that and just automatically create the the policy just automatically create the the policy just automatically create the the policy that we need to um to find all of these that we need to um to find all of these that we need to um to find all of these vulnerabilities wherever they are in any vulnerabilities wherever they are in any vulnerabilities wherever they are in any product. product. product. Similarly um when there is a Nvidia Similarly um when there is a Nvidia Similarly um when there is a Nvidia generated um patch for open source so generated um patch for open source so generated um patch for open source so when we fork that open source and we when we fork that open source and we when we fork that open source and we create that patch um you know it' be create that patch um you know it' be create that patch um you know it' be great if we could use AI to find that great if we could use AI to find that great if we could use AI to find that that patch was done and generate the VEX that patch was done and generate the VEX that patch was done and generate the VEX for that and then find that for that and then find that for that and then find that vulnerability vulnerability vulnerability uh mapping to the custom version in the uh mapping to the custom version in the uh mapping to the custom version in the global vex mappings. So we have um we do global vex mappings. So we have um we do global vex mappings. So we have um we do have a tool at NVIDIA that um is have a tool at NVIDIA that um is have a tool at NVIDIA that um is released the vulnerability analysis for released the vulnerability analysis for released the vulnerability analysis for container scanner agent blueprint. It is container scanner agent blueprint. It is container scanner agent blueprint. It is quite a mouthful. The the blueprint is quite a mouthful. The the blueprint is quite a mouthful. The the blueprint is uh open source so you can find on uh open source so you can find on uh open source so you can find on Nvidia's website. I'm sorry to not link Nvidia's website. I'm sorry to not link Nvidia's website. I'm sorry to not link it here. Um but it does actually take a it here. Um but it does actually take a it here. Um but it does actually take a container image the sbomb for that container image the sbomb for that container image the sbomb for that container image and it will um use will container image and it will um use will container image and it will um use will do analysis to determine what the do analysis to determine what the do analysis to determine what the suggested vex details should be. So suggested vex details should be. So suggested vex details should be. So we're also integrating that into our we're also integrating that into our we're also integrating that into our workflow so that we can suggest any of workflow so that we can suggest any of workflow so that we can suggest any of the analysis also on these parent images the analysis also on these parent images the analysis also on these parent images um and um and um and then on the final image as well. So we then on the final image as well. So we then on the final image as well. So we really want to be able to do as much really want to be able to do as much really want to be able to do as much suggestion as possible and then have the suggestion as possible and then have the suggestion as possible and then have the um analysist analysist yes review all of um analysist analysist yes review all of um analysist analysist yes review all of that in the end and show which of these that in the end and show which of these that in the end and show which of these came from the parent image which of came from the parent image which of came from the parent image which of these came from AI like we think this is these came from AI like we think this is these came from AI like we think this is AI thinks that this is the analysis for AI thinks that this is the analysis for AI thinks that this is the analysis for this vulnerability um and which we can this vulnerability um and which we can this vulnerability um and which we can just not give with any great uh accuracy just not give with any great uh accuracy just not give with any great uh accuracy any sort of suggestion so that we're any sort of suggestion so that we're any sort of suggestion so that we're trying to kind of build that whole trying to kind of build that whole trying to kind of build that whole trifecta into our reporting trifecta into our reporting trifecta into our reporting tooling. I think that might be it. Did tooling. I think that might be it. Did tooling. I think that might be it. Did you have anything else you wanted to you have anything else you wanted to you have anything else you wanted to add? add? add? Okay. Any questions? Anything that Okay. Any questions? Anything that Okay. Any questions? Anything that wasn't clear? I know we wasn't clear? I know we wasn't clear? I know we There is a question on the Discord. There is a question on the Discord. There is a question on the Discord. Um is is the vulnerability analysis use is is the vulnerability analysis use is is the vulnerability analysis use reused for common software component so reused for common software component so reused for common software component so you don't have to redo it for each VEX you don't have to redo it for each VEX you don't have to redo it for each VEX statement. I think so unless that's a trick I think so unless that's a trick I think so unless that's a trick question. question. question. Yes. Yes. Yes. Any questions in the room? Uh so just maybe I didn't understand Uh so just maybe I didn't understand Uh so just maybe I didn't understand this. So all of the vexes that you issue this. So all of the vexes that you issue this. So all of the vexes that you issue are for the patched oss components or are for the patched oss components or are for the patched oss components or for other vulnerabilities as well? Other for other vulnerabilities as well? Other for other vulnerabilities as well? Other ones as well. So we have for patch and ones as well. So we have for patch and ones as well. So we have for patch and that's mostly for the using the global that's mostly for the using the global that's mostly for the using the global vex and then we have um unaffected false vex and then we have um unaffected false vex and then we have um unaffected false positive positive positive and unaffected false positive I think so and unaffected false positive I think so and unaffected false positive I think so tri yeah triage exploitable but we don't tri yeah triage exploitable but we don't tri yeah triage exploitable but we don't really issue vexes for those okay really issue vexes for those okay really issue vexes for those okay they're just kind of like left out right they're just kind of like left out right they're just kind of like left out right now and so there is a scanning tool on now and so there is a scanning tool on now and so there is a scanning tool on the NGC catalog it will show all the the NGC catalog it will show all the the NGC catalog it will show all the vulnerabilities and then it will show vulnerabilities and then it will show vulnerabilities and then it will show the VEX details for the ones that are the VEX details for the ones that are the VEX details for the ones that are not exploitable and and when you issue not exploitable and and when you issue not exploitable and and when you issue access for uh vulnerabilities on the access for uh vulnerabilities on the access for uh vulnerabilities on the nonpatch OSS components do inherit those nonpatch OSS components do inherit those nonpatch OSS components do inherit those as well. Yes, in most cases we do. Okay. as well. Yes, in most cases we do. Okay. as well. Yes, in most cases we do. Okay. There are some that like if it requires There are some that like if it requires There are some that like if it requires configuration or um you know an configuration or um you know an configuration or um you know an environment or dependency then we want environment or dependency then we want environment or dependency then we want the the the the the the release the product manager that's release the product manager that's release the product manager that's releasing to make sure that those have releasing to make sure that those have releasing to make sure that those have not or like the security pick that's not or like the security pick that's not or like the security pick that's releasing to make sure that that has not releasing to make sure that that has not releasing to make sure that that has not changed. Okay. Yeah. Thanks. Yeah. Oh, hello. Um, do you have any like hello. Um, do you have any like hello. Um, do you have any like enforcement steps in place in the build enforcement steps in place in the build enforcement steps in place in the build pipeline pipeline pipeline to like ensure people are using these to like ensure people are using these to like ensure people are using these maintained parent images for maintained parent images for maintained parent images for example? So today we're really kind of example? So today we're really kind of example? So today we're really kind of selling this as like an efficiency selling this as like an efficiency selling this as like an efficiency um booster, right? So that you don't um booster, right? So that you don't um booster, right? So that you don't have to go the the product manager have to go the the product manager have to go the the product manager doesn't have to go through the open- doesn't have to go through the open- doesn't have to go through the open- source review board and the source review board and the source review board and the vulnerability analysis for every final vulnerability analysis for every final vulnerability analysis for every final image that's going through. But we are image that's going through. But we are image that's going through. But we are working closely with the product teams working closely with the product teams working closely with the product teams to try to put a gate as well on the the to try to put a gate as well on the the to try to put a gate as well on the the build pipeline. Mostly because we're build pipeline. Mostly because we're build pipeline. Mostly because we're finding that unfortunately some teams finding that unfortunately some teams finding that unfortunately some teams are still using versions old uh parent are still using versions old uh parent are still using versions old uh parent images and so they really want to get images and so they really want to get images and so they really want to get away from that. So, it's more to move away from that. So, it's more to move away from that. So, it's more to move everybody to the the latest and greatest everybody to the the latest and greatest everybody to the the latest and greatest versions of those parent images. Um, it versions of those parent images. Um, it versions of those parent images. Um, it is a little bit hard, right, to find the is a little bit hard, right, to find the is a little bit hard, right, to find the right net for how many parent images right net for how many parent images right net for how many parent images should be in that approved parent image should be in that approved parent image should be in that approved parent image registry for a use case. So, that's kind registry for a use case. So, that's kind registry for a use case. So, that's kind of where we're having a hard time of where we're having a hard time of where we're having a hard time determining, can we really block a block determining, can we really block a block determining, can we really block a block the pipeline for that um or not? That the pipeline for that um or not? That the pipeline for that um or not? That makes sense. Thank you. Yep.