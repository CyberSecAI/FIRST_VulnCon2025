Kind: captions Language: en Hey everyone, thank you for the welcome. Hey everyone, thank you for the welcome. Hey everyone, thank you for the welcome. Um, my name is Oliver. I'm from the Um, my name is Oliver. I'm from the Um, my name is Oliver. I'm from the Google open source security team. Uh, Google open source security team. Uh, Google open source security team. Uh, really sad to not be able to make it to really sad to not be able to make it to really sad to not be able to make it to Vongcon in person this year, but I'm Vongcon in person this year, but I'm Vongcon in person this year, but I'm grateful to still have the opportunity grateful to still have the opportunity grateful to still have the opportunity to give this to give this to give this talk. Um, let's jump right in. Yeah. So the open-source in. Yeah. So the open-source in. Yeah. So the open-source vulnerability schema which I'm going to vulnerability schema which I'm going to vulnerability schema which I'm going to be talking about or or schema for short be talking about or or schema for short be talking about or or schema for short is a JSON schema we created as part of is a JSON schema we created as part of is a JSON schema we created as part of the open SSF for describing known the open SSF for describing known the open SSF for describing known vulnerabilities in open source packages. vulnerabilities in open source packages. vulnerabilities in open source packages. It's a very minimal schema and as you It's a very minimal schema and as you It's a very minimal schema and as you can see here we can actually squeeze in can see here we can actually squeeze in can see here we can actually squeeze in the entire schema structure into a the entire schema structure into a the entire schema structure into a single slide. So the schema was started about four So the schema was started about four So the schema was started about four years ago and has since seen adoption years ago and has since seen adoption years ago and has since seen adoption from most major language ecosystems and from most major language ecosystems and from most major language ecosystems and open-source vulnerability databases as open-source vulnerability databases as open-source vulnerability databases as well as Linux well as Linux well as Linux distributions. And one of our goals here distributions. And one of our goals here distributions. And one of our goals here was to foster a was to foster a was to foster a community-maintained, easy to use and community-maintained, easy to use and community-maintained, easy to use and comprehensive database for comprehensive database for comprehensive database for vulnerabilities. And we wanted to do it vulnerabilities. And we wanted to do it vulnerabilities. And we wanted to do it in an open-source friendly and developer in an open-source friendly and developer in an open-source friendly and developer friendly way. friendly way. friendly way. So today we have almost 300,000 So today we have almost 300,000 So today we have almost 300,000 advisories collected across 31 advisories collected across 31 advisories collected across 31 ecosystems and 21 vulnerability databases. So I wanted to talk about databases. So I wanted to talk about databases. So I wanted to talk about some of our guiding principles for the some of our guiding principles for the some of our guiding principles for the schema that we use for designing changes schema that we use for designing changes schema that we use for designing changes and additions. I've roughly categorized and additions. I've roughly categorized and additions. I've roughly categorized this into six principles. So there core this into six principles. So there core this into six principles. So there core use cases simplicity correctness and use cases simplicity correctness and use cases simplicity correctness and consistency prioritizing open source consistency prioritizing open source consistency prioritizing open source federated database model and backwards federated database model and backwards federated database model and backwards compatibility. And I'll go through what compatibility. And I'll go through what compatibility. And I'll go through what all of these all of these all of these mean. So when we first started this mean. So when we first started this mean. So when we first started this schema, we didn't actually have a lot of schema, we didn't actually have a lot of schema, we didn't actually have a lot of these very well thought out. So some of these very well thought out. So some of these very well thought out. So some of these, actually many of these are the these, actually many of these are the these, actually many of these are the result of years of iteration and a result of years of iteration and a result of years of iteration and a little bit of looking back and little bit of looking back and little bit of looking back and reflecting on where we think we made the reflecting on where we think we made the reflecting on where we think we made the right choices. Um let's start with the first and most Um let's start with the first and most Um let's start with the first and most important guiding principle for us which important guiding principle for us which important guiding principle for us which we prioritized from the very beginning. we prioritized from the very beginning. we prioritized from the very beginning. Um this was to build a format that was Um this was to build a format that was Um this was to build a format that was laser focused on solving a primary goal laser focused on solving a primary goal laser focused on solving a primary goal which is to enable software developers which is to enable software developers which is to enable software developers to accurately identify and remediate all to accurately identify and remediate all to accurately identify and remediate all known vulnerabilities in their open known vulnerabilities in their open known vulnerabilities in their open source dependencies. source dependencies. source dependencies. The emphasis here is on this being The emphasis here is on this being The emphasis here is on this being actionable with the recognition that actionable with the recognition that actionable with the recognition that software developers are often the ones software developers are often the ones software developers are often the ones at the receiving end of all at the receiving end of all at the receiving end of all vulnerability reports and are the ones vulnerability reports and are the ones vulnerability reports and are the ones being asked to resolve these issues. So this goal breaks down into issues. So this goal breaks down into issues. So this goal breaks down into two categories of users that we need to two categories of users that we need to two categories of users that we need to cater towards. The first is cater towards. The first is cater towards. The first is vulnerability databases where we obtain vulnerability databases where we obtain vulnerability databases where we obtain all of our vulnerability data. So the all of our vulnerability data. So the all of our vulnerability data. So the format needs to make it easy for any format needs to make it easy for any format needs to make it easy for any vulnerability database to adopt and vulnerability database to adopt and vulnerability database to adopt and export and also be able to also enable export and also be able to also enable export and also be able to also enable databases to express all of the databases to express all of the databases to express all of the information they want to information they want to information they want to express. The second is vulnerability express. The second is vulnerability express. The second is vulnerability scanners which connect software scanners which connect software scanners which connect software applications and sbombs to vulnerability applications and sbombs to vulnerability applications and sbombs to vulnerability databases. Scanners need to be able to databases. Scanners need to be able to databases. Scanners need to be able to produce automated, actionable, and produce automated, actionable, and produce automated, actionable, and accurate results using the feeds accurate results using the feeds accurate results using the feeds formatted in the OSP schema. formatted in the OSP schema. formatted in the OSP schema. Now, these aren't the only types of Now, these aren't the only types of Now, these aren't the only types of users that need to consume vulnerability users that need to consume vulnerability users that need to consume vulnerability data. For example, researchers might be data. For example, researchers might be data. For example, researchers might be interested in performing analysis of interested in performing analysis of interested in performing analysis of vulnerabilities that require richer vulnerabilities that require richer vulnerabilities that require richer information than what a vulnerability information than what a vulnerability information than what a vulnerability scanner scanner scanner needs. We generally consider these out needs. We generally consider these out needs. We generally consider these out of scope in that while we want to of scope in that while we want to of scope in that while we want to support these use cases, we wouldn't support these use cases, we wouldn't support these use cases, we wouldn't want to make any changes to support them want to make any changes to support them want to make any changes to support them that will compromise some of our main that will compromise some of our main that will compromise some of our main goals. And I talk a bit more about this goals. And I talk a bit more about this goals. And I talk a bit more about this later. This leads us to our second guiding This leads us to our second guiding This leads us to our second guiding principle which is simplicity. So a principle which is simplicity. So a principle which is simplicity. So a well-defined set of use cases allows the well-defined set of use cases allows the well-defined set of use cases allows the schema to remain concise and minimal. So schema to remain concise and minimal. So schema to remain concise and minimal. So the simplicity makes the schema easier the simplicity makes the schema easier the simplicity makes the schema easier for consumers to understand and easier for consumers to understand and easier for consumers to understand and easier for producers to for producers to for producers to adopt. Each field should serve a adopt. Each field should serve a adopt. Each field should serve a distinct purpose directly linked to the distinct purpose directly linked to the distinct purpose directly linked to the core use cases. And there must be a core use cases. And there must be a core use cases. And there must be a practical way for vulnerability um uh practical way for vulnerability um uh practical way for vulnerability um uh data producers to supply the data for data producers to supply the data for data producers to supply the data for each each each field. So aspirational fields which field. So aspirational fields which field. So aspirational fields which can't be realistically populated by can't be realistically populated by can't be realistically populated by databases nor realistically used by databases nor realistically used by databases nor realistically used by consumers must also be avoided. So I wanted to go into some avoided. So I wanted to go into some avoided. So I wanted to go into some examples of important fields and how examples of important fields and how examples of important fields and how they relate to the use cases that we they relate to the use cases that we they relate to the use cases that we outlined. outlined. outlined. So when we first started out the schema, So when we first started out the schema, So when we first started out the schema, we quickly realized the need for a field we quickly realized the need for a field we quickly realized the need for a field to mark a vulnerability as an alias of to mark a vulnerability as an alias of to mark a vulnerability as an alias of another. This is because it's common for another. This is because it's common for another. This is because it's common for there to be many different IDs used to there to be many different IDs used to there to be many different IDs used to refer to the same refer to the same refer to the same vulnerability. For example, the GitHub vulnerability. For example, the GitHub vulnerability. For example, the GitHub advisory database uses the ghsa dash advisory database uses the ghsa dash advisory database uses the ghsa dash prefix and the go vulnerability database prefix and the go vulnerability database prefix and the go vulnerability database uses the go dash prefix. The clear use uses the go dash prefix. The clear use uses the go dash prefix. The clear use case here for SK vulnerability scanners case here for SK vulnerability scanners case here for SK vulnerability scanners is that they need a clear way to is that they need a clear way to is that they need a clear way to dduplicate between different IDs for the dduplicate between different IDs for the dduplicate between different IDs for the same vulnerability when it comes to uh same vulnerability when it comes to uh same vulnerability when it comes to uh addressing addressing addressing them. Now, aliases aren't the only kind them. Now, aliases aren't the only kind them. Now, aliases aren't the only kind of uh field for recording relationships of uh field for recording relationships of uh field for recording relationships between vulnerability records. There between vulnerability records. There between vulnerability records. There could be many others, but we only want could be many others, but we only want could be many others, but we only want to record these relationships if they to record these relationships if they to record these relationships if they tie back to our use cases. tie back to our use cases. tie back to our use cases. So one recent relationship field we So one recent relationship field we So one recent relationship field we added was the upstream field to record added was the upstream field to record added was the upstream field to record vulnerabilities where one is upstream of vulnerabilities where one is upstream of vulnerabilities where one is upstream of another. A common example here is Linux another. A common example here is Linux another. A common example here is Linux distributions which often issue their distributions which often issue their distributions which often issue their own advisories based on upstream own advisories based on upstream own advisories based on upstream CVEEs. For example, the Ubuntu CVEEs. For example, the Ubuntu CVEEs. For example, the Ubuntu distribution issues Ubuntu security distribution issues Ubuntu security distribution issues Ubuntu security notices prefixed by USN which often also notices prefixed by USN which often also notices prefixed by USN which often also bundle multiple CVEes into a single bundle multiple CVEes into a single bundle multiple CVEes into a single record. record. record. Aliases wouldn't work here because of Aliases wouldn't work here because of Aliases wouldn't work here because of his bundling. Aliases would mean that his bundling. Aliases would mean that his bundling. Aliases would mean that every single bundle CVE is the exact every single bundle CVE is the exact every single bundle CVE is the exact same which is same which is same which is incorrect. So the justification for incorrect. So the justification for incorrect. So the justification for adding upstream was that there was a adding upstream was that there was a adding upstream was that there was a very clear use case. When a users is very clear use case. When a users is very clear use case. When a users is scanning a Linux machine or container, scanning a Linux machine or container, scanning a Linux machine or container, users want to know if it's affected by a users want to know if it's affected by a users want to know if it's affected by a specific upstream vulnerability such as specific upstream vulnerability such as specific upstream vulnerability such as a CVE. And if we record this upstream a CVE. And if we record this upstream a CVE. And if we record this upstream relationship, then there's a very clear relationship, then there's a very clear relationship, then there's a very clear and automatable way to re reason about and automatable way to re reason about and automatable way to re reason about this. And one of the most important pieces uh And one of the most important pieces uh And one of the most important pieces uh of a schema for vulnerabilities is uh of a schema for vulnerabilities is uh of a schema for vulnerabilities is uh enforcing consistency and enforcing consistency and enforcing consistency and correctness. So historically many correctness. So historically many correctness. So historically many including Google have had a lot of including Google have had a lot of including Google have had a lot of challenges with leveraging vulnerability challenges with leveraging vulnerability challenges with leveraging vulnerability feeds like the MVD or the CVE list in a feeds like the MVD or the CVE list in a feeds like the MVD or the CVE list in a machine automatable and consistent way. machine automatable and consistent way. machine automatable and consistent way. it was often really difficult to map it was often really difficult to map it was often really difficult to map those vulnerability feeds to the actual those vulnerability feeds to the actual those vulnerability feeds to the actual package names and versions used in package names and versions used in package names and versions used in actual software in a predictable actual software in a predictable actual software in a predictable way. This really shouldn't be the case way. This really shouldn't be the case way. This really shouldn't be the case particularly for open source ecosystems particularly for open source ecosystems particularly for open source ecosystems which have really well-defined name which have really well-defined name which have really well-defined name spaces and versioning rules. So as such spaces and versioning rules. So as such spaces and versioning rules. So as such the OSV schema we we try to strive to the OSV schema we we try to strive to the OSV schema we we try to strive to follow upstream rules for relevant follow upstream rules for relevant follow upstream rules for relevant ecosystems and we also try to enforce ecosystems and we also try to enforce ecosystems and we also try to enforce specific ways to encode and capitalize specific ways to encode and capitalize specific ways to encode and capitalize different fields. so that the producers different fields. so that the producers different fields. so that the producers know exactly what to output and know exactly what to output and know exactly what to output and consumers can confidently know how to consumers can confidently know how to consumers can confidently know how to consume the data in a consistent consume the data in a consistent consume the data in a consistent way. So two examples here are the Debian way. So two examples here are the Debian way. So two examples here are the Debian and Pippi or Python ecosystems. So and Pippi or Python ecosystems. So and Pippi or Python ecosystems. So Debian has many different ways to refer Debian has many different ways to refer Debian has many different ways to refer to their specific releases by either to their specific releases by either to their specific releases by either their code names or version numbers. And their code names or version numbers. And their code names or version numbers. And even these version numbers have some even these version numbers have some even these version numbers have some ambiguity. They could either be floating ambiguity. They could either be floating ambiguity. They could either be floating points or they could be integers. points or they could be integers. points or they could be integers. So here in our OSV schema, we enforce a So here in our OSV schema, we enforce a So here in our OSV schema, we enforce a specific way of encoding Debian releases specific way of encoding Debian releases specific way of encoding Debian releases to enforce consistency by referencing to enforce consistency by referencing to enforce consistency by referencing some authoritative list that Debian some authoritative list that Debian some authoritative list that Debian provides. Pippi also has really special provides. Pippi also has really special provides. Pippi also has really special rules for how to normalize and treat rules for how to normalize and treat rules for how to normalize and treat package names. There's actually an package names. There's actually an package names. There's actually an infinite number of ways to refer to the infinite number of ways to refer to the infinite number of ways to refer to the same Python package in the Pippi package same Python package in the Pippi package same Python package in the Pippi package ecosystem. So in our schema we recommend ecosystem. So in our schema we recommend ecosystem. So in our schema we recommend or we actually enforce that PPI package or we actually enforce that PPI package or we actually enforce that PPI package names are normalized according to the names are normalized according to the names are normalized according to the rules that are set out in Python. Another example is the Maven Python. Another example is the Maven Python. Another example is the Maven ecosystem which has really complicated ecosystem which has really complicated ecosystem which has really complicated rules for how version ordering is done. rules for how version ordering is done. rules for how version ordering is done. So version ordering is very important So version ordering is very important So version ordering is very important because it's necessary to match software because it's necessary to match software because it's necessary to match software components to vulnerability feeds. And components to vulnerability feeds. And components to vulnerability feeds. And we found that most open source we found that most open source we found that most open source ecosystems define their own set of ecosystems define their own set of ecosystems define their own set of version ordering rules that differ quite version ordering rules that differ quite version ordering rules that differ quite a a a lot. This means we need to treat lot. This means we need to treat lot. This means we need to treat versions in a different in different versions in a different in different versions in a different in different open source ecosystems very differently open source ecosystems very differently open source ecosystems very differently as there's no generalized way to compare as there's no generalized way to compare as there's no generalized way to compare version numbers in a vulnerability feed. version numbers in a vulnerability feed. version numbers in a vulnerability feed. They really depend on the package They really depend on the package They really depend on the package ecosystem that uh that package came from. Even sver itself is a bit of an from. Even sver itself is a bit of an from. Even sver itself is a bit of an overloaded term. So the official server overloaded term. So the official server overloaded term. So the official server 2.0 spec points to some very clear and 2.0 spec points to some very clear and 2.0 spec points to some very clear and unambiguous rules for version precedence unambiguous rules for version precedence unambiguous rules for version precedence and ordering. But in practice very few and ordering. But in practice very few and ordering. But in practice very few ecosystems actually follow these rules. ecosystems actually follow these rules. ecosystems actually follow these rules. So in a schema we distinguish between So in a schema we distinguish between So in a schema we distinguish between the strict server ordering as defined by the strict server ordering as defined by the strict server ordering as defined by the server 2.0 spec and ecosystem which the server 2.0 spec and ecosystem which the server 2.0 spec and ecosystem which refers to the specific rules for the refers to the specific rules for the refers to the specific rules for the relevant ecosystem. We also set out very clear rules for We also set out very clear rules for We also set out very clear rules for evaluating if a package at a given evaluating if a package at a given evaluating if a package at a given version is vulnerable according to a version is vulnerable according to a version is vulnerable according to a record by providing pseudo code that record by providing pseudo code that record by providing pseudo code that shows how to implement version matching shows how to implement version matching shows how to implement version matching using OSV data. And as we're dealing with open data. And as we're dealing with open data. And as we're dealing with open source, we don't just stop with linear source, we don't just stop with linear source, we don't just stop with linear version ranges. Open source also has a version ranges. Open source also has a version ranges. Open source also has a benefit of a source code and version benefit of a source code and version benefit of a source code and version control system information being control system information being control system information being available. So the same versioning scheme available. So the same versioning scheme available. So the same versioning scheme and evaluation rules we define and evaluation rules we define and evaluation rules we define generalizes pretty well to also handle generalizes pretty well to also handle generalizes pretty well to also handle nonlinear get versioning trees with nonlinear get versioning trees with nonlinear get versioning trees with different branches. So in this example different branches. So in this example different branches. So in this example we have a git commit tree where all the we have a git commit tree where all the we have a git commit tree where all the branches are vulnerable except for one branches are vulnerable except for one branches are vulnerable except for one containing a fix. And we encode this in containing a fix. And we encode this in containing a fix. And we encode this in pretty much exactly the same way as how pretty much exactly the same way as how pretty much exactly the same way as how we encode uh vulnerabilities for linear we encode uh vulnerabilities for linear we encode uh vulnerabilities for linear version ranges through the introduced version ranges through the introduced version ranges through the introduced and fixed and fixed and fixed events. The semantics here are that events. The semantics here are that events. The semantics here are that unless there is a fix specified within a unless there is a fix specified within a unless there is a fix specified within a branch that branch is considered to be vulnerable. Another example here shows vulnerable. Another example here shows vulnerable. Another example here shows how we can encode a similar situation how we can encode a similar situation how we can encode a similar situation where instead only a single branch where instead only a single branch where instead only a single branch contains the vulnerability. contains the vulnerability. contains the vulnerability. We don't automatically assume that all We don't automatically assume that all We don't automatically assume that all branches that don't have an explicit fix branches that don't have an explicit fix branches that don't have an explicit fix is vulnerable in this case. And to do is vulnerable in this case. And to do is vulnerable in this case. And to do this, we replace the fix event with a this, we replace the fix event with a this, we replace the fix event with a limit event. And again, all of the rules limit event. And again, all of the rules limit event. And again, all of the rules for for this are all described in the for for this are all described in the for for this are all described in the pseudo code that we provide. And it's pseudo code that we provide. And it's pseudo code that we provide. And it's exactly the same algorithm that works exactly the same algorithm that works exactly the same algorithm that works for linear version ranges as well. So another guiding principle for well. So another guiding principle for well. So another guiding principle for us is to keep the format focused on open us is to keep the format focused on open us is to keep the format focused on open source. So while we can already fit in source. So while we can already fit in source. So while we can already fit in some proprietary software and ecosystems some proprietary software and ecosystems some proprietary software and ecosystems without making any structural changes to without making any structural changes to without making any structural changes to the schema, we didn't want to compromise the schema, we didn't want to compromise the schema, we didn't want to compromise the schema's design and increase its the schema's design and increase its the schema's design and increase its complexity by trying to explicitly complexity by trying to explicitly complexity by trying to explicitly target broader target broader target broader scope. An example of this is identifying scope. An example of this is identifying scope. An example of this is identifying proprietary software. This is often proprietary software. This is often proprietary software. This is often really hard to do in a generalized way really hard to do in a generalized way really hard to do in a generalized way because proprietary software aren't part because proprietary software aren't part because proprietary software aren't part of any centralized package management of any centralized package management of any centralized package management system nor namespace. system nor namespace. system nor namespace. We then, for example, want to add CPEs We then, for example, want to add CPEs We then, for example, want to add CPEs to the schema because CPEs aren't to the schema because CPEs aren't to the schema because CPEs aren't predictable and don't fit well with our predictable and don't fit well with our predictable and don't fit well with our kind of general correctness and kind of general correctness and kind of general correctness and consistency consistency consistency principles. If there was a better principles. If there was a better principles. If there was a better identification mechanism for proprietary identification mechanism for proprietary identification mechanism for proprietary software, this might be something we software, this might be something we software, this might be something we want to reconsider. So, here's a related example reconsider. So, here's a related example reconsider. So, here's a related example of a change that we rejected uh to add a of a change that we rejected uh to add a of a change that we rejected uh to add a timestamp range type. So we have timestamp range type. So we have timestamp range type. So we have ecosystem and sway ranges to encode ecosystem and sway ranges to encode ecosystem and sway ranges to encode ranges of vulnerable versions but there ranges of vulnerable versions but there ranges of vulnerable versions but there wasn't a way to record timestamps wasn't a way to record timestamps wasn't a way to record timestamps marking vulnerable periods of marking vulnerable periods of marking vulnerable periods of time. The justification for this was time. The justification for this was time. The justification for this was that this was useful for example service that this was useful for example service that this was useful for example service providers to mark a time period in which providers to mark a time period in which providers to mark a time period in which the service was vulnerable. the service was vulnerable. the service was vulnerable. However, we we ended up deciding that However, we we ended up deciding that However, we we ended up deciding that this wasn't a good fit for open source, this wasn't a good fit for open source, this wasn't a good fit for open source, nor did it provide any actionable steps nor did it provide any actionable steps nor did it provide any actionable steps for a vulnerability scanner to make use for a vulnerability scanner to make use for a vulnerability scanner to make use of. So, we rejected this change at a of. So, we rejected this change at a of. So, we rejected this change at a time. The main uh the main consideration time. The main uh the main consideration time. The main uh the main consideration here is that if a vulnerability scanner here is that if a vulnerability scanner here is that if a vulnerability scanner reported uh this result, it really reported uh this result, it really reported uh this result, it really wasn't clear to the user what they can wasn't clear to the user what they can wasn't clear to the user what they can do about it. So the OSV schema also promotes a So the OSV schema also promotes a So the OSV schema also promotes a distributed model of home vulnerability distributed model of home vulnerability distributed model of home vulnerability databases maintained by the relevant databases maintained by the relevant databases maintained by the relevant communities or communities or communities or organizations. For example, the GitHub organizations. For example, the GitHub organizations. For example, the GitHub advisory database maintains a database advisory database maintains a database advisory database maintains a database for several ecosystems using the GHSA for several ecosystems using the GHSA for several ecosystems using the GHSA prefix. The Go community maintains a prefix. The Go community maintains a prefix. The Go community maintains a database using the Go prefix and Rust database using the Go prefix and Rust database using the Go prefix and Rust also maintains one using the Rustack also maintains one using the Rustack also maintains one using the Rustack prefix and so on and so forth. prefix and so on and so forth. prefix and so on and so forth. So this is very much aligned with the So this is very much aligned with the So this is very much aligned with the way open source works. We have different way open source works. We have different way open source works. We have different communities contributing to communities contributing to communities contributing to vulnerability data in a distributed way vulnerability data in a distributed way vulnerability data in a distributed way and most of them are also open such that and most of them are also open such that and most of them are also open such that corrections and changes can also be made corrections and changes can also be made corrections and changes can also be made just by filing an issue or opening a just by filing an issue or opening a just by filing an issue or opening a pull request. This model also has some request. This model also has some request. This model also has some significance when we're thinking about significance when we're thinking about significance when we're thinking about what to add to the schema. what to add to the schema. what to add to the schema. For example, we've seen requests to add For example, we've seen requests to add For example, we've seen requests to add EPSS and CISA CV status to the EPSS and CISA CV status to the EPSS and CISA CV status to the schema. However, under this distributed schema. However, under this distributed schema. However, under this distributed model, it doesn't really make much sense model, it doesn't really make much sense model, it doesn't really make much sense to have this as top level fields in the to have this as top level fields in the to have this as top level fields in the schema to be populated by the relevant schema to be populated by the relevant schema to be populated by the relevant home databases because both EPSS and home databases because both EPSS and home databases because both EPSS and CISA Kev come from a single CISA Kev come from a single CISA Kev come from a single authoritative authoritative authoritative source. That said though, we still want source. That said though, we still want source. That said though, we still want to make OSV schema easy to cross to make OSV schema easy to cross to make OSV schema easy to cross reference with this extra metadata. for reference with this extra metadata. for reference with this extra metadata. for example, through using the aliases field example, through using the aliases field example, through using the aliases field so that we so that users can easily so that we so that users can easily so that we so that users can easily cross cororrelate between OSB records cross cororrelate between OSB records cross cororrelate between OSB records and additional metadata such as EPSS and given the federated database EPSS and given the federated database EPSS and given the federated database model there's often very specific model there's often very specific model there's often very specific metadata the home databases want to metadata the home databases want to metadata the home databases want to express which doesn't make sense as top express which doesn't make sense as top express which doesn't make sense as top level fields because they're very level fields because they're very level fields because they're very specific to that database or ecosystem. specific to that database or ecosystem. specific to that database or ecosystem. We have extension points in the schema We have extension points in the schema We have extension points in the schema via the database specific or ecosystem via the database specific or ecosystem via the database specific or ecosystem specific fields where home databases can specific fields where home databases can specific fields where home databases can provide this additional metadata in the provide this additional metadata in the provide this additional metadata in the form of arbitrary form of arbitrary form of arbitrary JSON. For example, the go vulnerability JSON. For example, the go vulnerability JSON. For example, the go vulnerability database provides metadata for go import database provides metadata for go import database provides metadata for go import p parts and symbols that are relevant to p parts and symbols that are relevant to p parts and symbols that are relevant to a vulnerability. GitHub has additional a vulnerability. GitHub has additional a vulnerability. GitHub has additional triage metadata specific to GitHub and triage metadata specific to GitHub and triage metadata specific to GitHub and Ubuntu exposes a concept of IU priority Ubuntu exposes a concept of IU priority Ubuntu exposes a concept of IU priority in many of their records. The meaning of in many of their records. The meaning of in many of their records. The meaning of these are all very specific to those uh these are all very specific to those uh these are all very specific to those uh ecosystems or databases. And finally, the last guiding databases. And finally, the last guiding databases. And finally, the last guiding principle for us is that we will never principle for us is that we will never principle for us is that we will never make a breaking change. Breaking a make a breaking change. Breaking a make a breaking change. Breaking a format means that we have to start over format means that we have to start over format means that we have to start over again in fostering adoption. And it also again in fostering adoption. And it also again in fostering adoption. And it also causes fragmentation for causes fragmentation for causes fragmentation for consumers. What this means is that we consumers. What this means is that we consumers. What this means is that we will never remove fields nor change them will never remove fields nor change them will never remove fields nor change them in backwards incompatible ways. And this in backwards incompatible ways. And this in backwards incompatible ways. And this also means that there's extra scrutiny also means that there's extra scrutiny also means that there's extra scrutiny on adding new fields because the on adding new fields because the on adding new fields because the consequences of adding them are consequences of adding them are consequences of adding them are permanent. So we really need to make permanent. So we really need to make permanent. So we really need to make sure we get things right as much as we sure we get things right as much as we sure we get things right as much as we can as any mistakes that we regret later can as any mistakes that we regret later can as any mistakes that we regret later will live on forever. I also wanted to talk a bit about I also wanted to talk a bit about I also wanted to talk a bit about driving adoption and getting feedback on driving adoption and getting feedback on driving adoption and getting feedback on the schema. What has been really the schema. What has been really the schema. What has been really important for us is to provide an end important for us is to provide an end important for us is to provide an end toend set of reference tooling that toend set of reference tooling that toend set of reference tooling that makes use of vulnerability feeds makes use of vulnerability feeds makes use of vulnerability feeds formatted in OSV. And I'll come back to formatted in OSV. And I'll come back to formatted in OSV. And I'll come back to this slide later. So first we have OSVdev which is later. So first we have OSVdev which is later. So first we have OSVdev which is an aggregator of all OSV home databases. So, osv.dev provides a web UI for So, osv.dev provides a web UI for So, osv.dev provides a web UI for browsing and looking up details of browsing and looking up details of browsing and looking up details of vulnerability records and it also vulnerability records and it also vulnerability records and it also provides an API to query records provides an API to query records provides an API to query records programmatically. We also direct users programmatically. We also direct users programmatically. We also direct users to the specific upstream processes for a to the specific upstream processes for a to the specific upstream processes for a many record. For instance, if we're many record. For instance, if we're many record. For instance, if we're displaying a GHSA record and a user displaying a GHSA record and a user displaying a GHSA record and a user notices that there's some incorrect notices that there's some incorrect notices that there's some incorrect information, they can just click a information, they can just click a information, they can just click a button and we'll take them straight to button and we'll take them straight to button and we'll take them straight to the GitHub UI for submitting an advisory the GitHub UI for submitting an advisory the GitHub UI for submitting an advisory improvement. We also have client side tooling through We also have client side tooling through We also have client side tooling through a tool called OSV scanner and a library a tool called OSV scanner and a library a tool called OSV scanner and a library called OSV scanner and this provide out called OSV scanner and this provide out called OSV scanner and this provide out ofbox vulnerability scanner and ofbox vulnerability scanner and ofbox vulnerability scanner and libraries for scanning source and libraries for scanning source and libraries for scanning source and container images and it directly uses container images and it directly uses container images and it directly uses the data that we have in OS.dev. So developers and security teams OS.dev. So developers and security teams OS.dev. So developers and security teams can use these tools to get a list of can use these tools to get a list of can use these tools to get a list of vulnerabilities that affect them. So it vulnerabilities that affect them. So it vulnerabilities that affect them. So it works by analyzing source code file works by analyzing source code file works by analyzing source code file systems or container images to extract systems or container images to extract systems or container images to extract the sbomb or inventory of open source the sbomb or inventory of open source the sbomb or inventory of open source dependencies. These are then matched dependencies. These are then matched dependencies. These are then matched against the feeds in osv.dev to produce against the feeds in osv.dev to produce against the feeds in osv.dev to produce a list of a list of a list of vulnerabilities. And one of the core vulnerabilities. And one of the core vulnerabilities. And one of the core goals for these tools is is to try to goals for these tools is is to try to goals for these tools is is to try to make the results as actionable and make the results as actionable and make the results as actionable and accurate as possible by implementing accurate as possible by implementing accurate as possible by implementing ecosystem specific functionality such as ecosystem specific functionality such as ecosystem specific functionality such as dependency resolution algorithms or dependency resolution algorithms or dependency resolution algorithms or version ordering. version ordering. version ordering. And recall that every ecosystem has And recall that every ecosystem has And recall that every ecosystem has their own very specialized rules for their own very specialized rules for their own very specialized rules for handling version numbers. So we go to handling version numbers. So we go to handling version numbers. So we go to great pains to ensure that we have great pains to ensure that we have great pains to ensure that we have accuracy there uh in and covering a good accuracy there uh in and covering a good accuracy there uh in and covering a good coverage of all the major ecosystems. So providing this extra ecosystems. So providing this extra ecosystems. So providing this extra reference tooling has been incredibly reference tooling has been incredibly reference tooling has been incredibly helpful for us in building the OSV helpful for us in building the OSV helpful for us in building the OSV platform and in fostering adoption. platform and in fostering adoption. platform and in fostering adoption. Providing tools and services on top of Providing tools and services on top of Providing tools and services on top of OSV data helps foster adoption because OSV data helps foster adoption because OSV data helps foster adoption because users can easily see how OSV works and users can easily see how OSV works and users can easily see how OSV works and how it could be integrated into the how it could be integrated into the how it could be integrated into the workflows. And these tools explicitly workflows. And these tools explicitly workflows. And these tools explicitly address the primary use case we had in address the primary use case we had in address the primary use case we had in mind with the OSV schema. So they also mind with the OSV schema. So they also mind with the OSV schema. So they also serve as a great platform for us to serve as a great platform for us to serve as a great platform for us to obtain feedback both for the schema obtain feedback both for the schema obtain feedback both for the schema itself as well as in providing feedback itself as well as in providing feedback itself as well as in providing feedback to upstream home databases on their data to upstream home databases on their data to upstream home databases on their data quality. quality. quality. A lot of the time some of our users ask A lot of the time some of our users ask A lot of the time some of our users ask us whether if we can support a new feed us whether if we can support a new feed us whether if we can support a new feed and then we redirect them to the and then we redirect them to the and then we redirect them to the relevant upstream uh community that relevant upstream uh community that relevant upstream uh community that maintains that feed and it was a great maintains that feed and it was a great maintains that feed and it was a great way it's a great way for us to convince way it's a great way for us to convince way it's a great way for us to convince some of these communities to adopt the some of these communities to adopt the some of these communities to adopt the OSV schema as well. So what's next? I think OSV is well. So what's next? I think OSV is well. So what's next? I think OSV is fairly mature at this point in terms of fairly mature at this point in terms of fairly mature at this point in terms of being a schema for vulnerability being a schema for vulnerability being a schema for vulnerability records. But there are more problems to records. But there are more problems to records. But there are more problems to solve here. Beyond the problem of solve here. Beyond the problem of solve here. Beyond the problem of vulnerability records, one other vulnerability records, one other vulnerability records, one other prevalent problem in the vulnerability prevalent problem in the vulnerability prevalent problem in the vulnerability management space is that users of management space is that users of management space is that users of vulnerability scanners often have way vulnerability scanners often have way vulnerability scanners often have way too many false positives to deal with. too many false positives to deal with. too many false positives to deal with. One way to deal address this is Vex, but One way to deal address this is Vex, but One way to deal address this is Vex, but it's still unclear to us at least how it's still unclear to us at least how it's still unclear to us at least how VEX applies to open source, specifically VEX applies to open source, specifically VEX applies to open source, specifically open source libraries as opposed to end open source libraries as opposed to end open source libraries as opposed to end user user user applications. Given the distributed applications. Given the distributed applications. Given the distributed graph nature of open source, can we graph nature of open source, can we graph nature of open source, can we somehow share and propagate vex somehow share and propagate vex somehow share and propagate vex statements in a way that reduces statements in a way that reduces statements in a way that reduces investigation time for everybody? So here's an example of what everybody? So here's an example of what everybody? So here's an example of what I mean. Let's say package C on the left I mean. Let's say package C on the left I mean. Let's say package C on the left is vulnerable to a CVE and my is vulnerable to a CVE and my is vulnerable to a CVE and my application reaches package C while my application reaches package C while my application reaches package C while my direct dependencies A and B. My goal direct dependencies A and B. My goal direct dependencies A and B. My goal after running a vulnerability scanner after running a vulnerability scanner after running a vulnerability scanner that says CVE I'm affected by the CVE is that says CVE I'm affected by the CVE is that says CVE I'm affected by the CVE is to figure out if I'm actually affected. If both package A and package affected. If both package A and package affected. If both package A and package B publish a form of a intermediate back B publish a form of a intermediate back B publish a form of a intermediate back statement saying that they're not statement saying that they're not statement saying that they're not affected by the CV and package C, then I affected by the CV and package C, then I affected by the CV and package C, then I can also assume that my application is can also assume that my application is can also assume that my application is not affected by the vulnerability. On the other hand, if at least one of A On the other hand, if at least one of A On the other hand, if at least one of A or B doesn't have a vex statement or has or B doesn't have a vex statement or has or B doesn't have a vex statement or has a vex statement saying they are a vex statement saying they are a vex statement saying they are impacted, then when we assume that our impacted, then when we assume that our impacted, then when we assume that our application is likely also application is likely also application is likely also impacted. Now, this is just a small impacted. Now, this is just a small impacted. Now, this is just a small example, but you can imagine this being example, but you can imagine this being example, but you can imagine this being scaled up to a full dependency graph scaled up to a full dependency graph scaled up to a full dependency graph with hundreds or or thousands of with hundreds or or thousands of with hundreds or or thousands of dependencies. dependencies. dependencies. In this way, we can perhaps share some In this way, we can perhaps share some In this way, we can perhaps share some of the work done to investigate vex of the work done to investigate vex of the work done to investigate vex applicability and propagate this applicability and propagate this applicability and propagate this information through open source information through open source information through open source dependency graphs so that everybody uh dependency graphs so that everybody uh dependency graphs so that everybody uh shares the burden of investigating vex shares the burden of investigating vex shares the burden of investigating vex and uh we have a easier job to determine and uh we have a easier job to determine and uh we have a easier job to determine whether if we are actually affected by whether if we are actually affected by whether if we are actually affected by vulnerabilities or not. So one way perhaps for this to work is So one way perhaps for this to work is So one way perhaps for this to work is for there to be a convention for package for there to be a convention for package for there to be a convention for package managers or project source version managers or project source version managers or project source version control to adopt where they store a file control to adopt where they store a file control to adopt where they store a file that encodes these intermediate vex that encodes these intermediate vex that encodes these intermediate vex files. Then users of a package can files. Then users of a package can files. Then users of a package can automatically discover and piece this automatically discover and piece this automatically discover and piece this together with other intermediate vex together with other intermediate vex together with other intermediate vex statements into their own dependency statements into their own dependency statements into their own dependency graphs. graphs. graphs. This will help users determine and This will help users determine and This will help users determine and reduce the investigation time for reduce the investigation time for reduce the investigation time for transitive vulnerabilities that don't transitive vulnerabilities that don't transitive vulnerabilities that don't actually impact the application and actually impact the application and actually impact the application and allow them to more easily produce a vex allow them to more easily produce a vex allow them to more easily produce a vex a full vex statement for their a full vex statement for their a full vex statement for their application. This is all just a very application. This is all just a very application. This is all just a very vague idea and we don't know what this vague idea and we don't know what this vague idea and we don't know what this will look like exactly or how it will will look like exactly or how it will will look like exactly or how it will work in practice but I think this will work in practice but I think this will work in practice but I think this will be one of the next things for us to be one of the next things for us to be one of the next things for us to tackle in the space of open source tackle in the space of open source tackle in the space of open source management. Um and that's all I have for management. Um and that's all I have for management. Um and that's all I have for today. So thank you very much for coming today. So thank you very much for coming today. So thank you very much for coming to my talk. to my talk. to my talk. Uh thank you. So um I have a question Uh thank you. So um I have a question Uh thank you. So um I have a question about the breaking changes. Uh clarif I about the breaking changes. Uh clarif I about the breaking changes. Uh clarif I wanted a little bit of clarification on wanted a little bit of clarification on wanted a little bit of clarification on that if you wouldn't mind going back to that if you wouldn't mind going back to that if you wouldn't mind going back to that slide. that slide. that slide. Um so whatever changes you make going to Um so whatever changes you make going to Um so whatever changes you make going to be breaking. You're never going to be breaking. You're never going to be breaking. You're never going to update all old records. Mistakes will update all old records. Mistakes will update all old records. Mistakes will live on forever. Can't you imagine a live on forever. Can't you imagine a live on forever. Can't you imagine a scenario in that case where you would scenario in that case where you would scenario in that case where you would then have to add a new field that almost then have to add a new field that almost then have to add a new field that almost replicates the older fields since you replicates the older fields since you replicates the older fields since you want to change the schema around want to change the schema around want to change the schema around it and then that just doesn't that just it and then that just doesn't that just it and then that just doesn't that just bog everything down if you're adding and bog everything down if you're adding and bog everything down if you're adding and adding and adding fields never taking adding and adding fields never taking adding and adding fields never taking anything away. anything away. anything away. Right. Right. So so there's a few pieces Right. Right. So so there's a few pieces Right. Right. So so there's a few pieces there. So one to clarify the backward there. So one to clarify the backward there. So one to clarify the backward compatibility guarantee. So what we compatibility guarantee. So what we compatibility guarantee. So what we promise is that if you're if you're a promise is that if you're if you're a promise is that if you're if you're a client targeting an older version of a client targeting an older version of a client targeting an older version of a schema, you can safely ignore any fields schema, you can safely ignore any fields schema, you can safely ignore any fields that you don't understand because you that you don't understand because you that you don't understand because you haven't updated your client to support haven't updated your client to support haven't updated your client to support the latest the latest the latest version. Um and similarly for clients version. Um and similarly for clients version. Um and similarly for clients targeting newer versions, they can targeting newer versions, they can targeting newer versions, they can always expect uh all the fields to always expect uh all the fields to always expect uh all the fields to always uh be there. They'll never be always uh be there. They'll never be always uh be there. They'll never be removed. And and the key here, I think, removed. And and the key here, I think, removed. And and the key here, I think, is is that is is that is is that um we we really try to keep the schema um we we really try to keep the schema um we we really try to keep the schema to be very minimal. So there's actually to be very minimal. So there's actually to be very minimal. So there's actually a very high bar for us to add a new a very high bar for us to add a new a very high bar for us to add a new field. I think that's what's kind of field. I think that's what's kind of field. I think that's what's kind of helped us keep the schema quite lean and helped us keep the schema quite lean and helped us keep the schema quite lean and not introduce a lot of bloat over not introduce a lot of bloat over not introduce a lot of bloat over time. time. time. Um does that answer your question? Yeah, Um does that answer your question? Yeah, Um does that answer your question? Yeah, I guess so.